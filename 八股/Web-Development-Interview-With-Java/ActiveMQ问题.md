# ActiveMQ问题

## 1、什么是ActiveMQ？

`ActiveMQ`是一种开源的，**实现了JMS1.1规范的**，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。

## 2、activeMQ的作用以及原理？

实现系统间的通信，实现系统间**解耦、异步、削峰**等作用。

原理就是生产者生产消息， 把消息发送给`activemq`。 `Activemq` 接收到消息， 然后查看有多少个消费者， 然后把消息转发给消费者， 此过程中生产者无需参与。 消费者接收到消息后做相应的处理和生产者没有任何关系。

## 3、activeMQ的有几种通信方式？（网易）

1. 点对点通信：一个生产者对应一个消费者。
2. 发布订阅模式：类似于微信的公众号，一个生产者对应多个消费者。

### 两种模式的异同？

订阅发布模式，没有订阅者的话消息会被丢弃。点对点模式消息会保存到`activeMQ`服务器中。

订阅发布模式随着订阅的增长性能会逐渐降低，点对点模式不会。

## 4、如何解决消息丢失问题？（网易）

点对点模式的话， 如果消息发送不成功此消息默认会保存到 `activemq` 服务端直到有消费者将其消费， 所以此时消息是不会丢失的。

## 5、如何解决消息重复消费的问题？（网易）

1. MySQL数据库中添加一张**消息消费记录表**，记录已经消费过的消息的ID，每当一个消息进来先判断它是否被执行过，如果执行过就放弃。如果没执行过就开始执行消息，消息执行完之后将该消息的ID存入表中。

2. 由connection创建session时有两个参数供选择，一个是**事务**，一个是**签收机制**。什么是签收机制？消费者接受到消息后，需要告诉消息服务器，我收到消息了。当消息服务器收到回执后，**本条消息将失效**。因此签收将对PTP模式产生很大影响。如果消费者收到消息后，并不签收，那么本条消息继续有效，很可能会被其他消费者消费掉！从而导致重复消费。

   消息的签收有三种可供选择：

   ```Java
   AUTO_ACKNOWLEDGE：//表示在消费者receive消息的时候自动的签收
   CLIENT_ACKNOWLEDGE：//表示消费者receive消息后必须手动的调用acknowledge()方法进行签收
   DUPS_OK_ACKNOWLEDGE：//签不签收无所谓了，只要消费者能够容忍重复的消息接受，当然这样会降低Session的开销
   ```

   一般生产上会选取CLIENT_ACKNOWLEDGE作为签收策略。因为接收到了消息，并不意味着成功的处理了消息，假设我们采用手动签收的方式，**只有在消息成功处理的前提下才进行签收**，那么只要消息处理失败，那么消息还有效，仍然会继续消费，直至成功处理！




## 6、Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么不同？（美团）

| 特性           | ActiveMQ   | RabbitMQ | RocketMQ             | Kafka            |
| -------------- | ---------- | -------- | -------------------- | ---------------- |
| **单机吞吐量** | 万级       | 万级     | 10万级               | 10万级           |
| **时效性**     | ms         | 微秒级   | ms                   | ms               |
| **可用性**     | 高         | 高       | 非常高               | 非常高           |
| **消息可靠性** | 可能会丢失 |          | 可以到达0丢失        | 可以到达0丢失    |
|                |            |          | Java编写，阿里开源。 | 适用于大数据领域 |



## 7、ActiveMQ如何保障高可用？（美团）

搭建集群、外部持久化（服务器意外宕机，消息依然存在）、签收、事务。

## 8、利用MQ异步下订单？（美团）（滴滴）

秒杀环境下，一旦`redis`库存扣减成功了，就相当于完成了购物操作，由于秒杀的特殊性，如果对每一个对于数据库的写订单、减库存操作的立即执行的话，对数据库的压力过大。

于是，我们将每一条秒杀成功的消息封装后存入消息队列中，然后给用户返回“抢购排队中”的结果。然后将消息队列中的下单操作一个个的写入数据库中、下订单、写订单详情。最终返回用户“秒杀成功”。比起多线程同步的修改数据库的操作，这样一来大大的缓解了数据库的连接压力。

## 9、MQ中的基本组件有哪些？

连接工厂、连接、会话（目的地（queue、topic）、生产者、消费者）包含两个参数**事务、确认机制**。其中事务偏向于生产者，确认机制偏向于消费者。

## 10、消息消费的方式？（美团）

jms是**异步通信**，发送方发送消息后就可以继续其它业务，而不用阻塞等等接收方响应。但接收方在接收消息上有两种模式：一种是同步接收消息，一种是异步接收消息。下面的示例中也会分别演示

![](https://img-blog.csdn.net/20160120152036648)

1. 同步方式：接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞。
2. 异步方式：当消息队列有消息时会调用接收者的`onMessage`方法，接收者不用阻塞等待，可执行其它业务。 实现接口`MessageListener`，注册监听器 `consumer.setMessageListener(this);` (异步接收) ，实现 `onMessage`方法。

## 11、activeMQ在项目中的应用有哪些？（美团）

`Activemq`在项目中主要是完成系统之间通信，并且将系统之间的调用进行解耦。例如在添加、修改商品信息后，需要将商品信息同步到索引库、同步缓存中的数据以及生成静态页面一系列操作。在此场景下就可以使用`activemq`。一旦后台对商品信息进行修改后，就向`activemq`发送一条消息，然后通过`activemq`将消息发送给消息的消费端，消费端接收到消息可以进行相应的业务处理。

## 12、单点登录系统中如果cookie禁用，该如何解决？

可以使用url中带参数，把token传递给服务端。http的get方式。

## 13、订单表的数据量太大,我把订单分到许多表中,那么我我想用一条sql查处所有的订单,怎么解决?（滴滴）

分库情况下：可以使用mycat数据库中间件实现多个表的统一管理。虽然物理上是把一个表中的数据保存到多个数据库中，但是逻辑上还是一个表，使用一条sql语句就可以把数据全部查询出来。

## 14、activeMQ的事务？（美团）

**session提供了commit以及rollback方法进行事务的提交与回滚**。在事务状态下进行发送操作，消息并未真正投递到中间件。而只有进行session.commit操作之后，消息才会发送到中间件，再转发到适当的消费者进行处理。如果是调用rollback操作，则表明，当前事务期间内所发送的消息都取消掉。

开启事务后，producer发送message时在message中带有transaction_ID。broker收到message后判断是否有transaction_ID，如果有就把message保存在transaction store中，等待commit或者rollback消息。所以`ActiveMQ`的事务是针对broker而不是producer的，不管session是否commit，broker都会收到message。如果producer发送模式选择了persistent，那么message过期后会进入死亡队列。在message进入死亡队列之前，`ActiveMQ`会删除message中的transaction_ID，这样过期的message就不在事务中了，不会保存在transaction store中，会直接进入死亡队列。

## 15、activeMQ的外部持久化机制？

levelDB、kahaDB、JDBC

## 16、activeMQ的的签收机制？

默认使用自动签收机制。生产上推荐使用client_ackonwlege模式。可以确保消息被消费后才签收。这样的话就不会有重复消费的问题出现了。
